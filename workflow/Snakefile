# TODO: add benchmarks
# TODO: change runtime formatting in config

# PREAMBLE #

# set glob wildcards
(
    SAMPLE,
    FRAC,
) = glob_wildcards(config["path"]["input"] + "/{sample}_{fraction}.fastq.gz")

# remove duplicates
SAMPLE = list(set(SAMPLE))
FRAC = list(set(FRAC))
config["path"]["temp"] = config["path"]["temp"]

onstart:
    touch(config["path"]["temp"])


# GLOBAL FUNCTIONS #

def get_checkv_threshold(threshold):
    """
    Gets the threshold for checkv wuality control.
    """
    if threshold.lower() == "complete":
        return "$8~/(Complete)/"
    elif threshold.lower() == "high":
        return "$8~/(High-quality|Complete)/"
    elif threshold.lower() == "medium":
        return "$8~/(Medium-quality|High-quality|Complete)/"
    elif threshold.lower() == "low":
        return "$8~/(Low-quality|Medium-quality|High-quality|Complete)/"
    elif threshold.lower() == "not-determined":
        return "$8~/(Not-determined|Low-quality|Medium-quality|High-quality|Complete)/"
    else:
        return "$8~/(Medium-quality|High-quality|Complete)/"


def vibrant_virome(is_virome):
    """
    Gathers if the input is virome.
    """
    if is_virome.lower == "yes":
        return "-virome"
    else:
        return ""


# WORKFLOW #

rule all:
    input:
        config["path"]["temp"] + "/finished_qc",
        config["path"]["temp"] + "/finished_assembly",
        config["path"]["temp"] + "/finished_identification",
    shell:
        """
        rm {input}
        echo "All Done!"
        """


# QUALITY CONTROL #

rule fastqc_raw:
    input:
        expand(
            config["path"]["input"] + "/{sample}_{fraction}.fastq.gz",
            sample=SAMPLE,
            fraction=FRAC,
        ),
    output:
        dir = directory(config["path"]["output"] + "/fastqc_raw/")
    threads: config["threads"]
    conda:
        config["path"]["envs"] + "/fastqc.yaml"
    message:
        "Executing FASTQC quality control on raw reads from: {input}."
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    log:
            config["path"]["log"] + "/fastqc_raw.log",
    benchmark:
        config["path"]["benchmark"] + "/fastqc_raw.txt",
    shell:
        """
        mkdir -p {output.dir}
        fastqc -o {output.dir} {input} &> {log}
        """

rule fastp_pe:
    """
    Performes quality control/pre-processing of the raw reads
    """
    input:
        R1 = expand(
            config["path"]["input"] + "/{sample}_1.fastq.gz",
            sample=SAMPLE,
        ),
        R2 = expand(
            config["path"]["input"] + "/{sample}_2.fastq.gz",
            sample=SAMPLE,
        ),
    output:
        dir = directory(config["path"]["output"] + "/fastp_pe/"),
        R1 = expand(
            config["path"]["output"] + "/fastp_pe/{sample}_1.fastq",
            sample=SAMPLE,
        ),
        R2 = expand(
            config["path"]["output"] + "/fastp_pe/{sample}_2.fastq",
            sample=SAMPLE,
        ),
        html = expand(
            config["path"]["output"] + "/fastp_pe/{sample}.html",
            sample=SAMPLE,
        ),
        json = expand(
            config["path"]["output"] + "/fastp_pe/{sample}.json",
            sample=SAMPLE,
        ),
    log:
        config["path"]["log"] + "/fastp_pe.log",
    benchmark:
            config["path"]["benchmark"] + "/fastp_pe.txt",
    resources:
        mem_mb=config["normal_mem"],
        # runtime=config["normal_time"],
    conda:
        config["path"]["envs"] + "/fastp.yaml"
    threads: config["threads"]
    shell:
        """
        mkdir -p {output.dir}
        fastp -i {input.R1} -I {input.R2} -o {output.R1} -O {output.R2}\
        -h {output.html} -j {output.json}\
        &> {log}
        """

rule fastqc_qc:
    """
    Performes quality control of processed QC reads
    """
    input:
        rules.fastp_pe.output.R1,
        rules.fastp_pe.output.R2,
    output:
        dir = directory(config["path"]["output"] + "/fastqc_qc/"),
    threads: config["threads"]
    conda:
        config["path"]["envs"] + "/fastqc.yaml"
    message:
        "Executing FASTQC quality control on trimmed reads from:{input} files."
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    log:
        config["path"]["log"] + "/fastqc_qc.log",
    benchmark:
            config["path"]["benchmark"] + "/fastqc_qc.txt",
    shell:
        """
        mkdir -p {output.dir}
        fastqc {input} -o {output.dir} &> {log}
        """

rule qc:
    input:
        rules.fastqc_raw.output,
        rules.fastp_pe.output,
        rules.fastqc_qc.output,
    output:
        config["path"]["temp"] + "/finished_qc"
    threads: 1
    shell:
        """
        touch {output}
        """


# ASSEMBLY #

rule metaSpades:
    """
    Assembles all sequences with metaSpades
    """
    input:
        R1 = rules.fastp_pe.output.R1,
        R2 = rules.fastp_pe.output.R2,
    output:
        dir = directory(expand(
            config["path"]["output"] + "/metaSpades/{sample}/",
            sample=SAMPLE,
        )),
    params:
        temp_dir = config["path"]["temp"] + "/metaSpades/",
    message:
        "Executing assembly of paired end files R1: {input.R1} and on R2: {input.R2}"
    conda:
        config["path"]["envs"] + "/metaSpades.yaml"
    log:
        config["path"]["log"] + "/metaSpades.log",
    benchmark:
            config["path"]["benchmark"] + "/metaSpades.txt",
    threads: config["threads"]
    resources:
        mem_mb=config["big_mem"],
        # runtime=config["big_time"],
    shell:
        """
        mkdir -p {output.dir}
        metaspades.py -1 {input.R1} -2 {input.R2} -o {output.dir}\
        --tmp-dir {params.temp_dir} -t {threads}\
        &> {log}
        """

rule metaQUAST:
    """
    Performes quality control on all assembled contigs
    with the reference database RefSeq Viral
    """
    params:
        reference = config["path"]["database"]["RefSeq"],
    input:
        [str(subdir) + "/contigs.fasta" for subdir in rules.metaSpades.output.dir]
    output:
        dir = directory(config["path"]["output"] + "/metaQUAST/"),
    message:
        "Running metaQUAST on {input}"
    conda:
        config["path"]["envs"] + "/metaQUAST.yaml"
    log:
        config["path"]["log"] + "/metaQUAST.log",
    benchmark:
        config["path"]["benchmark"] + "/metaQUAST.txt",
    threads: config["threads"]
    resources:
        mem_mb=config["metaquast_mem"],
        # runtime=config["metaquast_time"],
    shell:
        """
        metaquast.py {input} -o {output.dir}\
        -r {params.reference} --threads {threads} --max-ref-number 0 &> {log}
        """

rule assembly:
    input:
        rules.metaSpades.output,
        rules.metaQUAST.output,
    output:
        config["path"]["temp"] + "/finished_assembly"
    threads: 1
    shell:
        """
        touch {output}
        """


# VIRAL IDENTIFICATION #

rule virsorter2_pass1:
    """
    Performes the first pass of viral identification with virsorter2
    """
    params:
        cutoff_length=config["virsorter2"]["pass1"]["min_lenght"],
        cutoff_score=config["virsorter2"]["pass1"]["min_score"],
    input:
        [str(subdir) + "/contigs.fasta" for subdir in rules.metaSpades.output.dir]
    output:
        dir = directory(expand(
            config["path"]["output"] + "/virsorter2_pass1/{sample}/",
            sample=SAMPLE,
        ))
    message:
        "Resources used; threads: {threads}"
    singularity:
        "docker://jiarong/virsorter:2.2.3"
    log:
        config["path"]["log"] + "/virsorter2_pass1.log",
    benchmark:
        config["path"]["benchmark"] + "virsorter2_pass1.txt",
    threads: config["threads"]
    resources:
        mem_mb=config["big_mem"],
        # runtime=config["normal_time"],
    shell:
        """
        virsorter run -w {output.dir} \
            -i {input} \
            -j {threads} --include-groups dsDNAphage,ssDNA,NCLDV,RNA,lavidaviridae \
            --min-length {params.cutoff_length} \
            --min-score {params.cutoff_score} \
            --keep-original-seq all\
            &> {log}
        """

rule vibrant_pass1:
    """
    Performes the first pass of viral identification with VIBRANT
    """
    input:
        [str(subdir) + "/contigs.fasta" for subdir in rules.metaSpades.output.dir]
    output:
        dir = directory(expand(
            config["path"]["output"] + "/vibrant_pass1/{sample}/",
            sample=SAMPLE,
        ))
    params:
        db_dir="$CONDA_PREFIX/share/vibrant-1.2.1/db/databases",
        files_dir="$CONDA_PREFIX/share/vibrant-1.2.1/db/files",
        virome=vibrant_virome(config["vibrant"]["is_virome"]),
    conda:
        config["path"]["envs"] + "/vibrant.yaml"
    log:
        config["path"]["log"] + "vibrant_pass1.log",
    benchmark:
        config["path"]["benchmark"] + "/vibrant_pass1.txt",
    threads: config["threads"]
    resources:
        mem_mb=config["big_mem"],
        # runtime=config["normal_time"],
    shell:
        """
        VIBRANT_run.py -i {input}\
            -t {threads}\
            -folder {output.dir}\
            -d {params.db_dir}\
            -m {params.files_dir}\
            {params.virome}\
            &> {log}
        """

# rule checkv_virsorter2:
#     """
#     Performes Quality control on identified viral sequences
#     """
#     params:
#         db_dir=config["path"]["database"]["checkv"],
#     input:
#         expand(
#             config["path"]["output"] + "/virsorter2_pass1/{sample}/final-viral-combined.fa",
#             sample=SAMPLE,
#         )
#     output:
#         dir = directory(expand(
#             config["path"]["output"] + "/checkv/virsorter2_pass1/{sample}/",
#             sample=SAMPLE,
#         )),
#     conda:
#         config["path"]["envs"] + "/checkv.yaml"
#     log:
#         config["path"]["log"] + "/checkv_virsorter2_pass1.log",
#     benchmark:
#         config["path"]["benchmark"] + "/checkv_virsorter2_pass1.txt",
#     threads: config["threads"]
#     resources:
#         mem_mb=config["normal_mem"],
#         # runtime=config["small_time"],
#     shell:
#         """
#         diamond makedb --in {params.db_dir}/genome_db/checkv_reps.faa \
#             --db {params.db_dir}/genome_db/checkv_reps\
#             &>{log}
#         checkv end_to_end {input} {output.dir} -t {threads} -d {params.db_dir}\
#             &>> {log}
#         """


# rule checkv_vibrant:
#     """
#     Performes Quality control on identified viral sequences
#     """
#     params:
#         dir_db=config["database_dir"]["checkv"],
#     input:
#         [directory(str(subdir) + "/VIBRANT_contigs/VIBRANT_phages_contigs/") for subdir in rules.vibrant_pass1.output.dir]
#     output:
#         dir = directory(expand(
#             config["path"]["output"] + "/checkv/vibrant/{sample}/",
#             sample=SAMPLE,
#         )),
#     conda:
#         config["path"]["envs"] + "/checkv.yaml"
#     log:
#         "vibrant_checkv.log",
#     benchmark:
#         config["path"]["benchmark"] + "/checkv_vibrant.txt",
#     threads: 4
#     resources:
#         mem_mb=config["normal_mem"],
#         runtime=config["small_time"],
#     shell:
#         """
#     diamond makedb --in {params.dir_db}/genome_db/checkv_reps.faa \
#         --db {params.dir_db}/genome_db/checkv_reps\
#         &>{log}
#     checkv end_to_end {input} {params.out_dir}{wildcards.sample} -t {threads} -d {params.dir_db}\
#         &>> {log}
#     """


rule identification:
    input:
        rules.virsorter2_pass1.output,
        rules.vibrant_pass1.output,
        # rules.checkv_virsorter2.output,
        # rules.checkv_vibrant.output,
    output:
        config["path"]["temp"] + "/finished_identification"
    threads: 1
    shell:
        """
        touch {output}
        """