# TODO: add benchmarks
# TODO: change runtime formatting in config

# PREAMBLE #

# set glob wildcards
(
    SAMPLE,
    FRAC,
) = glob_wildcards(config["path"]["input"] + "/{sample}_{fraction}.fastq.gz")

# remove duplicates
SAMPLE = list(set(SAMPLE))
FRAC = list(set(FRAC))
config["path"]["temp"] = config["path"]["temp"]

onstart:
    touch(config["path"]["temp"])
    # print("Starting workflow")
    # print("Samples: " + ", ".join(SAMPLE))


# GLOBAL FUNCTIONS #

def get_checkv_threshold(threshold):
    """
    Gets the threshold for checkv wuality control.
    """
    if threshold.lower() == "complete":
        return "$8~/(Complete)/"
    elif threshold.lower() == "high":
        return "$8~/(High-quality|Complete)/"
    elif threshold.lower() == "medium":
        return "$8~/(Medium-quality|High-quality|Complete)/"
    elif threshold.lower() == "low":
        return "$8~/(Low-quality|Medium-quality|High-quality|Complete)/"
    elif threshold.lower() == "not-determined":
        return "$8~/(Not-determined|Low-quality|Medium-quality|High-quality|Complete)/"
    else:
        return "$8~/(Medium-quality|High-quality|Complete)/"


def vibrant_virome(is_virome):
    """
    Gathers if the input is virome.
    """
    if is_virome.lower == "yes":
        return "-virome"
    else:
        return ""


# WORKFLOW #

rule all:
    input:
        config["path"]["temp"] + "/finished_qc",
        config["path"]["temp"] + "/finished_assembly",
        config["path"]["temp"] + "/finished_identification",
    shell:
        """
        echo "All Done!"
        rm {input}
        """


# QUALITY CONTROL #

rule fastqc_raw:
    input:
        expand(
            config["path"]["input"] + "/{sample}_{fraction}.fastq.gz",
            sample=SAMPLE,
            fraction=FRAC,
        ),
    output:
        dir = directory(config["path"]["output"] + "/fastqc_raw/"),
        report = expand(
            config["path"]["output"] + "/fastqc_raw/{sample}_{fraction}_fastqc.html",
            sample=SAMPLE,
            fraction=FRAC,
        ),
    threads: config["threads"]
    conda:
        config["path"]["envs"] + "/fastqc.yaml"
    message:
        "Executing FASTQC quality control on raw reads from: {input}."
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    log:
            config["path"]["log"] + "/fastqc_raw.log",
    benchmark:
        config["path"]["benchmark"] + "/fastqc_raw.txt",
    shell:
        """
        mkdir -p {output.dir}
        fastqc -o {output.dir} {input} &> {log}
        """

rule fastp_pe:
    """
    Performes quality control/pre-processing of the raw reads
    """
    input:
        R1 = expand(
            config["path"]["input"] + "/{sample}_1.fastq.gz",
            sample=SAMPLE,
        ),
        R2 = expand(
            config["path"]["input"] + "/{sample}_2.fastq.gz",
            sample=SAMPLE,
        ),
    output:
        dir = directory(config["path"]["output"] + "/fastp_pe/"),
        R1 = expand(
            config["path"]["output"] + "/fastp_pe/{sample}_1.fastq",
            sample=SAMPLE,
        ),
        R2 = expand(
            config["path"]["output"] + "/fastp_pe/{sample}_2.fastq",
            sample=SAMPLE,
        ),
        html = expand(
            config["path"]["output"] + "/fastp_pe/{sample}.html",
            sample=SAMPLE,
        ),
        json = expand(
            config["path"]["output"] + "/fastp_pe/{sample}.json",
            sample=SAMPLE,
        ),
    log:
        config["path"]["log"] + "/fastp_pe.log",
    benchmark:
            config["path"]["benchmark"] + "/fastp_pe.txt",
    resources:
        mem_mb=config["normal_mem"],
        # runtime=config["normal_time"],
    conda:
        config["path"]["envs"] + "/fastp.yaml"
    threads: config["threads"]
    shell:
        """
        mkdir -p {output.dir}
        fastp -i {input.R1} -I {input.R2} -o {output.R1} -O {output.R2}\
        -h {output.html} -j {output.json}\
        &> {log}
        """

rule fastqc_qc:
    """
    Performes quality control of processed QC reads
    """
    input:
        rules.fastp_pe.output.R1,
        rules.fastp_pe.output.R2,
    output:
        dir = directory(config["path"]["output"] + "/fastqc_qc/"),
        report = expand(
            config["path"]["output"] + "/fastqc_qc/{sample}_{fraction}_fastqc.html",
            sample=SAMPLE,
            fraction=FRAC,
        ),
    threads: config["threads"]
    conda:
        config["path"]["envs"] + "/fastqc.yaml"
    message:
        "Executing FASTQC quality control on trimmed reads from:{input} files."
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    log:
        config["path"]["log"] + "/fastqc_qc.log",
    benchmark:
            config["path"]["benchmark"] + "/fastqc_qc.txt",
    shell:
        """
        mkdir -p {output.dir}
        fastqc {input} -o {output.dir} &> {log}
        """

rule qc:
    input:
        rules.fastqc_raw.output,
        rules.fastp_pe.output,
        rules.fastqc_qc.output,
    output:
        config["path"]["temp"] + "/finished_qc"
    threads: 1
    shell:
        """
        touch {output}
        """


# ASSEMBLY #

rule metaSpades:
    """
    Assembles all sequences with metaSpades
    """
    input:
        R1 = rules.fastp_pe.output.R1,
        R2 = rules.fastp_pe.output.R2,
    output:
        dir = directory(expand(
            config["path"]["output"] + "/metaSpades/{sample}/",
            sample=SAMPLE,
        )),
        contigs = expand(
            config["path"]["output"] + "/metaSpades/{sample}/contigs.fasta",
            sample=SAMPLE,
        ),
        scaffolds = expand(
            config["path"]["output"] + "/metaSpades/{sample}/scaffolds.fasta",
            sample=SAMPLE,
        ),
    params:
        temp_dir = config["path"]["temp"] + "/metaSpades/",
    message:
        "Executing assembly of paired end files R1: {input.R1} and on R2: {input.R2}"
    conda:
        config["path"]["envs"] + "/metaSpades.yaml"
    log:
        config["path"]["log"] + "/metaSpades.log",
    benchmark:
            config["path"]["benchmark"] + "/metaSpades.txt",
    threads: config["threads"]
    resources:
        mem_mb=config["big_mem"],
        # runtime=config["big_time"],
    shell:
        """
        mkdir -p {output.dir}
        metaspades.py -1 {input.R1} -2 {input.R2} -o {output.dir}\
        --tmp-dir {params.temp_dir} -t {threads}\
        &> {log}
        """

rule metaQUAST:
    """
    Performes quality control on all assembled contigs
    with the reference database RefSeq Viral
    """
    params:
        reference = config["path"]["database"]["RefSeq"],
    input:
        rules.metaSpades.output.contigs,
    output:
        dir = directory(config["path"]["output"] + "/metaQUAST/"),
        report = config["path"]["output"] + "/metaQUAST/report.html",
        transposed_report = config["path"]["output"] + "/metaQUAST/combined_reference/transposed_report.tsv",
    message:
        "Running metaQUAST on {input}"
    conda:
        config["path"]["envs"] + "/metaQUAST.yaml"
    log:
        config["path"]["log"] + "/metaQUAST.log",
    benchmark:
        config["path"]["benchmark"] + "/metaQUAST.txt",
    threads: config["threads"]
    resources:
        mem_mb=config["metaquast_mem"],
        # runtime=config["metaquast_time"],
    shell:
        """
        metaquast.py {input} -o {output.dir}\
        -r {params.reference} --threads {threads} --max-ref-number 0 &> {log}
        """

rule assembly:
    input:
        rules.metaSpades.output,
        rules.metaQUAST.output,
    output:
        config["path"]["temp"] + "/finished_assembly"
    threads: 1
    shell:
        """
        touch {output}
        """


# VIRAL IDENTIFICATION #

# rule virsorter2_pass1:
#     """
#     Performes the first pass of viral identification with virsorter2
#     """
#     params:
#         cutoff_length=config["virsorter2"]["pass1"]["min_lenght"],
#         cutoff_score=config["virsorter2"]["pass1"]["min_score"],
#     input:
#         rules.metaSpades.output.contigs,
#     output:
#         dir = directory(expand(
#             config["path"]["output"] + "/virsorter2_pass1/{sample}/",
#             sample=SAMPLE,
#         )),
#         combined = expand(
#             config["path"]["output"] + "/virsorter2_pass1/{sample}/final-viral-combined.fa",
#             sample=SAMPLE,
#         )
#     message:
#         "Resources used; threads: {threads}"
#     singularity:
#         "docker://jiarong/virsorter:2.2.3"
#     log:
#         config["path"]["log"] + "/virsorter2_pass1.log",
#     benchmark:
#         config["path"]["benchmark"] + "/virsorter2_pass1.txt",
#     threads: config["threads"]
#     resources:
#         mem_mb=config["big_mem"],
#         # runtime=config["normal_time"],
#     shell:
#         """
#         virsorter run -w {output.dir} \
#             -i {input} \
#             -j {threads} --include-groups dsDNAphage,ssDNA,NCLDV,RNA,lavidaviridae \
#             --min-length {params.cutoff_length} \
#             --min-score {params.cutoff_score} \
#             --keep-original-seq all\
#             &> {log}
#         """

rule vibrant_pass1:
    """
    Performes the first pass of viral identification with VIBRANT
    """
    input:
        rules.metaSpades.output.contigs,
    output:
        dir = directory(expand(
            config["path"]["output"] + "/vibrant_pass1/{sample}/",
            sample=SAMPLE,
        )),
        # combined = expand(
        #     config["path"]["output"] + "/vibrant_pass1/{sample}/final-viral-combined.fa",
        #     sample=SAMPLE,
        # )
    params:
        db_dir=config["path"]["database"]["vibrant"] + "/databases",
        files_dir=config["path"]["database"]["vibrant"] + "/files",
        virome=vibrant_virome(config["vibrant"]["is_virome"]),
    conda:
        config["path"]["envs"] + "/vibrant.yaml"
    log:
        config["path"]["log"] + "/vibrant_pass1.log",
    benchmark:
        config["path"]["benchmark"] + "/vibrant_pass1.txt",
    threads: config["threads"]
    resources:
        mem_mb=config["big_mem"],
        # runtime=config["normal_time"],
    shell:
        """
        mkdir {output.dir}
        VIBRANT_run.py -i {input}
            -t {threads}\
            -folder {output.dir}\
            -db {params.db_dir}\
            -files {params.files_dir}\
            {params.virome}\
            &> {log}
        """

# rule checkv_virsorter2:
#     """
#     Performes Quality control on identified viral sequences
#     """
#     params:
#         db_dir=config["path"]["database"]["checkv"],
#     input:
#         rules.virsorter2_pass1.output.combined,
#     output:
#         dir = directory(expand(
#             config["path"]["output"] + "/checkv/virsorter2_pass1/{sample}/",
#             sample=SAMPLE,
#         )),
#     conda:
#         config["path"]["envs"] + "/checkv.yaml"
#     log:
#         config["path"]["log"] + "/checkv_virsorter2_pass1.log",
#     benchmark:
#         config["path"]["benchmark"] + "/checkv_virsorter2_pass1.txt",
#     threads: config["threads"]
#     resources:
#         mem_mb=config["normal_mem"],
#         # runtime=config["small_time"],
#     shell:
#         """
#         diamond makedb --in {params.db_dir}/genome_db/checkv_reps.faa \
#             --db {params.db_dir}/genome_db/checkv_reps\
#             &>{log}
#         checkv end_to_end {input} {output.dir} -t {threads} -d {params.db_dir}\
#             &>> {log}
#         """


# rule checkv_vibrant:
#     """
#     Performes Quality control on identified viral sequences
#     """
#     params:
#         dir_db=config["path"]["database"]["checkv"],
#     input:
#         [directory(str(subdir) + "final-viral-combined.fa") for subdir in rules.vibrant_pass1.output.dir]
#     output:
#         dir = directory(expand(
#             config["path"]["output"] + "/checkv/vibrant/{sample}/",
#             sample=SAMPLE,
#         )),
#     conda:
#         config["path"]["envs"] + "/checkv.yaml"
#     log:
#         "vibrant_checkv.log",
#     benchmark:
#         config["path"]["benchmark"] + "/checkv_vibrant.txt",
#     threads: 4
#     resources:
#         mem_mb=config["normal_mem"],
#         runtime=config["small_time"],
#     shell:
#         """
#         diamond makedb --in {params.dir_db}/genome_db/checkv_reps.faa \
#             --db {params.dir_db}/genome_db/checkv_reps\
#             &>{log}
#         checkv end_to_end {input} {params.out_dir}{wildcards.sample} -t {threads} -d {params.dir_db}\
#             &>> {log}
#         """

# rule filter_contigs_virsorter2:
#     """
#     Gathers only relevant sequences with above threshold score
#     """
#     params:
#         criteria=get_checkv_threshold(config["checkv_threshold"]),
#     input:
#         summary=expand(
#             "results/checkv/virsorter2/{{sample}}/quality_summary.tsv", sample=SAMPLE
#         ),
#         all_contigs=expand(
#             "results/checkv/virsorter2/{{sample}}/combined.fna", sample=SAMPLE
#         ),
#     output:
#         filtered_contigs_viruses="results/checkv/virsorter2/{sample}/filtered/filtered_combined.fna",
#         filtered_contigs_ID="results/checkv/virsorter2/{sample}/filtered/filtered_contigs",
#     conda:
#         envs_dir + "/seqtk.yaml"
#     benchmark:
#         "benchmarks/checkv/virsorter2/{sample}/filter_contigs.tsv"
#     log:
#         "logs/checkv/virsorter2/filter_{sample}_checkv.log",
#     threads: 2
#     resources:
#         mem_mb=config["small_mem"],
#         runtime=config["small_time"],
#     shell:
#         """
#         awk -F '\t' '{params.criteria}  {{print $1}}' {input.summary} > {output.filtered_contigs_ID}
#         seqtk subseq {input.all_contigs} {output.filtered_contigs_ID} > {output.filtered_contigs_viruses}
#     """


# rule filter_contigs_vibrant:
#     """
#     Gathers only relevant sequences with above threshold score
#     """
#     params:
#         criteria=get_checkv_threshold(config["checkv_threshold"]),
#     input:
#         summary=expand(
#             "results/checkv/vibrant/{{sample}}/quality_summary.tsv", sample=SAMPLE
#         ),
#         all_contigs=expand(
#             "results/checkv/vibrant/{{sample}}/combined.fna", sample=SAMPLE
#         ),
#     output:
#         filtered_contigs_viruses="results/checkv/vibrant/{sample}/filtered/filtered_combined.fna",
#         filtered_contigs_ID="results/checkv/vibrant/{sample}/filtered/filtered_contigs",
#     conda:
#         envs_dir + "/seqtk.yaml"
#     benchmark:
#         "benchmarks/checkv/vibrant/{sample}/filter_contigs.tsv"
#     log:
#         "logs/checkv/vibrant/filter_{sample}_checkv.log",
#     threads: 2
#     resources:
#         mem_mb=config["small_mem"],
#         runtime=config["small_time"],
#     shell:
#         """
#         awk -F '\t' '{params.criteria}  {{print $1}}' {input.summary} > {output.filtered_contigs_ID}
#         seqtk subseq {input.all_contigs} {output.filtered_contigs_ID} > {output.filtered_contigs_viruses}
#     """


# rule combine_results_virsorter2:
#     """
#     Combine all results from virus identifiaction of all samples with virsorter2
#     """
#     input:
#         expand(
#             "results/checkv/virsorter2/{sample}/filtered/filtered_combined.fna",
#             sample=SAMPLE,
#         ),
#     output:
#         "results/cdhit/prep/combined_virsorter2.fasta",
#     conda:
#         envs_dir + "/cdhit.yaml"
#     log:
#         "logs/virsorter2_cdhit_prep.log",
#     threads: 2
#     resources:
#         mem_mb=config["small_mem"],
#         runtime=config["small_time"],
#     shell:
#         """
#         cat {input} > {output}
#     """


# rule combine_results_vibrant:
#     """
#     Combine all results from virus identifiaction of all samples with VIBRANT
#     """
#     input:
#         expand(
#             "results/checkv/vibrant/{sample}/filtered/filtered_combined.fna",
#             sample=SAMPLE,
#         ),
#     output:
#         "results/cdhit/prep/combined_vibrant.fasta",
#     conda:
#         envs_dir + "/cdhit.yaml"
#     log:
#         "logs/vibrant_cdhit_prep.log",
#     threads: 2
#     resources:
#         mem_mb=config["small_mem"],
#         runtime=config["small_time"],
#     shell:
#         """
#         cat {input} > {output}
#     """


# rule combine_all_results:
#     """
#     Combine all results from both virus identifiaction tools
#     """
#     input:
#         vibrant="results/cdhit/prep/combined_vibrant.fasta",
#         virsorter2="results/cdhit/prep/combined_virsorter2.fasta",
#     output:
#         "results/cdhit/prep/combined_all.fasta",
#     conda:
#         envs_dir + "/cdhit.yaml"
#     log:
#         "logs/combine_all_cdhit_prep.log",
#     threads: 2
#     resources:
#         mem_mb=config["small_mem"],
#         runtime=config["tiny_time"],
#     shell:
#         """
#         cat {input.vibrant} {input.virsorter2} > {output}
#     """


# rule dereplication:
#     """
#     Performs dereplication with clustering on the viral sequences
#     """
#     input:
#         "results/cdhit/prep/combined_all.fasta",
#     output:
#         "results/cdhit/derep95_combined.fasta",
#     conda:
#         envs_dir + "/cdhit.yaml"
#     log:
#         "logs/combined_cdhit.log",
#     threads: 8
#     resources:
#         mem_mb=config["normal_mem"],
#         runtime=config["small_time"],
#     shell:
#         """
#         cd-hit-est\
#         -T {threads}\
#         -M {resources.mem_mb}\
#         -i {input}\
#         -o {output}\
#         -c 0.95\
#         -aS 0.85\
#         -n 9\
#         -d 0\
#         -p 1\
#         -t 4\
#         -g 1\
#         &> {log}

#     """


# rule transform_vOTUs:
#     """
#     Renames viral sequences to unique vOTU_# names
#     """
#     input:
#         "results/cdhit/derep95_combined.fasta",
#     output:
#         "results/cdhit/vOTU_derep95_combined.fasta",
#     resources:
#         mem_mb=config["small_mem"],
#         runtime=config["tiny_time"],
#     conda:
#         envs_dir + "/seqtk.yaml"
#     log:
#         "logs/transform_vOTUs.log",
#     shell:
#         """
#         awk '/^>/{{print ">vOTU_" ++i; next}}{{print}}' {input} > {output}
#     """


# rule vibrant_pass2:
#     """
#     Runs VIBRANT on the vOTUs
#     """
#     input:
#         contigs="results/cdhit/vOTU_derep95_combined.fasta",
#     output:
#         "results/vibrant/vOTU/VIBRANT_vOTU_derep95_combined/VIBRANT_phages_vOTU_derep95_combined/vOTU_derep95_combined.phages_combined.fna",
#     params:
#         db_dir="$CONDA_PREFIX/share/vibrant-1.2.1/db/databases",
#         files_dir="$CONDA_PREFIX/share/vibrant-1.2.1/db/files",
#         results="results/vibrant/vOTU/",
#         virome=vibrant_virome(config["vibrant_settings"]["is_virome"]),
#     conda:
#         envs_dir + "/vibrant.yaml"
#     log:
#         "logs/VIBRANT/vOTU_VIBRANT.log",
#     benchmark:
#         "benchmarks/vibrant/vOTU_vibrant.tsv"
#     threads: 16
#     resources:
#         mem_mb=config["big_mem"],
#         runtime=config["normal_time"],
#     shell:
#         """
#     rm -rd results/vibrant/vOTU/*
#     VIBRANT_run.py -i {input.contigs}\
#         -t {threads}\
#         -folder {params.results}\
#         -d {params.db_dir}\
#         -m {params.files_dir}\
#         {params.virome}\
#         &> {log}
#     """


# rule virsorter2_pass2:
#     """
#     Runs virsorter2 on the vOTUs
#     """
#     params:
#         out_dir="results/virsorter2/",
#         cutoff_length=config["virsorter2_settings"]["pass2"]["min_lenght"],
#         cutoff_score=config["virsorter2_settings"]["pass2"]["min_score"],
#     input:
#         assembled_contigs="results/cdhit/vOTU_derep95_combined.fasta",
#     output:
#         "results/virsorter2/pass2/for-dramv/viral-affi-contigs-for-dramv.tab",
#         "results/virsorter2/pass2/for-dramv/final-viral-combined-for-dramv.fa",
#         "results/virsorter2/pass2/final-viral-combined.fa",
#     message:
#         "Resources used; threads: {threads}"
#     benchmark:
#         "benchmarks/virsorter2/pass2_virsorter2.tsv"
#     singularity:
#         "docker://jiarong/virsorter:2.2.3"
#     log:
#         "logs/virsorter2/virsorter2_pass2.log",
#     threads: 8
#     resources:
#         mem_mb=config["big_mem"],
#         runtime=config["normal_time"],
#     shell:
#         """
#     rm -rdf {params.out_dir}pass2/*
#     virsorter run -w {params.out_dir}pass2/ \
#         --seqname-suffix-off\
#         --viral-gene-enrich-off\
#         --prep-for-dramv\
#         -i {input} \
#         -j {threads} --include-groups dsDNAphage,ssDNA,NCLDV,RNA,lavidaviridae \
#         --min-length 3000 \
#         --min-score 0.5 \
#         --keep-original-seq all\
#         &> {log}
#     """


# rule checkv_vOTU_virsorter2:
#     """
#     Runs Quality control on the vOTUs after virsorter2
#     """
#     params:
#         out_dir="results/checkv/vOTU/virsorter2/",
#         dir_db=config["database_dir"]["checkv"],
#     input:
#         "results/virsorter2/pass2/final-viral-combined.fa",
#     output:
#         "results/checkv/vOTU/virsorter2/quality_summary.tsv",
#     conda:
#         envs_dir + "/checkv.yaml"
#     log:
#         "logs/checkv/vOTU_checkv_virsorter2.log",
#     benchmark:
#         "benchmarks/checkv/vOTU_checkv_virsorter2.tsv"
#     threads: 2
#     resources:
#         mem_mb=config["normal_mem"],
#         runtime=config["small_time"],
#     shell:
#         """
#     rm -rdf results/checkv/vOTU/virsorter2
#     diamond makedb --in {params.dir_db}/genome_db/checkv_reps.faa \
#         --db {params.dir_db}/genome_db/checkv_reps\
#         &>{log}
#     checkv end_to_end {input} {params.out_dir} -t {threads} -d {params.dir_db}\
#         &>> {log}
#     """


# rule checkv_vOTU_vibrant:
#     """
#     Runs Quality control on the vOTUs after VIBRANT
#     """
#     params:
#         out_dir="results/checkv/vOTU/vibrant/",
#         dir_db=config["database_dir"]["checkv"],
#     input:
#         "results/vibrant/vOTU/VIBRANT_vOTU_derep95_combined/VIBRANT_phages_vOTU_derep95_combined/vOTU_derep95_combined.phages_combined.fna",
#     output:
#         "results/checkv/vOTU/vibrant/quality_summary.tsv",
#     conda:
#         envs_dir + "/checkv.yaml"
#     log:
#         "logs/checkv/vOTU_checkv_vibrant.log",
#     benchmark:
#         "benchmarks/checkv/vOTU_checkv_vibrant.tsv"
#     threads: 2
#     resources:
#         mem_mb=config["normal_mem"],
#         runtime=config["small_time"],
#     shell:
#         """
#     rm -rdf results/checkv/vOTU/vibrant
#     diamond makedb --in {params.dir_db}/genome_db/checkv_reps.faa \
#         --db {params.dir_db}/genome_db/checkv_reps\
#         &>{log}
#     checkv end_to_end {input} {params.out_dir} -t {threads} -d {params.dir_db}\
#         &>> {log}
#     """

rule identification:
    input:
        # rules.virsorter2_pass1.output,
        rules.vibrant_pass1.output,
        # rules.checkv_virsorter2.output,
        # rules.checkv_vibrant.output,
    output:
        config["path"]["temp"] + "/finished_identification"
    threads: 1
    shell:
        """
        touch {output}
        """