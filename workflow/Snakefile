# TODO: change runtime formatting in config
# TODO: write all the messages

# PREAMBLE #

# set glob wildcards
(
    SAMPLE,
    FRAC,
) = glob_wildcards(config["path"]["input"] + "/{sample}_{frac}.fastq.gz")

# remove duplicates
SAMPLE = list(set(SAMPLE))
FRAC = list(set(FRAC))
config["path"]["temp"] = config["path"]["temp"]


onstart:
    touch(config["path"]["temp"])
    touch(config["path"]["log"])
    print("Samples: " + ", ".join(SAMPLE))


# GLOBAL FUNCTIONS #


def get_min_quality(threshold):
    """
    Gets the threshold for checkv wuality control.
    """
    if threshold.lower() == "complete":
        return "$8~/(Complete)/"
    elif threshold.lower() == "high":
        return "$8~/(High-quality|Complete)/"
    elif threshold.lower() == "medium":
        return "$8~/(Medium-quality|High-quality|Complete)/"
    elif threshold.lower() == "low":
        return "$8~/(Low-quality|Medium-quality|High-quality|Complete)/"
    elif threshold.lower() == "not-determined":
        return "$8~/(Not-determined|Low-quality|Medium-quality|High-quality|Complete)/"
    else:
        return "$8~/(Medium-quality|High-quality|Complete)/"


def vibrant_virome(is_virome):
    """
    Gathers if the input is virome.
    """
    if is_virome.lower == "yes":
        return "-virome"
    else:
        return ""


# QUALITY CONTROL #


rule fastqc_raw:
    input:
        list(
            set(
                expand(
                    config["path"]["input"] + "/{sample}_{frac}.fastq.gz",
                    sample=SAMPLE,
                    frac=FRAC,
                )
            )
        ),
    output:
        dir=directory(config["path"]["output"] + "/fastqc_raw/"),
        report=list(
            set(
                expand(
                    config["path"]["output"]
                    + "/fastqc_raw/{sample}_{frac}_fastqc.html",
                    sample=SAMPLE,
                    frac=FRAC,
                )
            )
        ),
    threads: config["threads"]
    conda:
        config["path"]["envs"] + "/fastqc.yaml"
    message:
        "[fastqc_raw] Executing FASTQC quality control on raw reads..."
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    log:
        config["path"]["log"] + "/fastqc_raw.log",
    benchmark:
        config["path"]["benchmark"] + "/fastqc_raw.txt"
    shell:
        """
        mkdir -p {output.dir}
        fastqc -o {output.dir} {input} &> {log}
        """


rule fastp_pe:
    """
    Performes quality control/pre-processing of the raw reads
    """
    input:
        R1=expand(
            config["path"]["input"] + "/{sample}_1.fastq.gz",
            sample=SAMPLE,
        ),
        R2=expand(
            config["path"]["input"] + "/{sample}_2.fastq.gz",
            sample=SAMPLE,
        ),
    output:
        dir=directory(config["path"]["output"] + "/fastp_pe/"),
        R1=expand(
            config["path"]["output"] + "/fastp_pe/{sample}_1.fastq",
            sample=SAMPLE,
        ),
        R2=expand(
            config["path"]["output"] + "/fastp_pe/{sample}_2.fastq",
            sample=SAMPLE,
        ),
        html=expand(
            config["path"]["output"] + "/fastp_pe/{sample}.html",
            sample=SAMPLE,
        ),
        json=expand(
            config["path"]["output"] + "/fastp_pe/{sample}.json",
            sample=SAMPLE,
        ),
    log:
        config["path"]["log"] + "/fastp_pe.log",
    benchmark:
        config["path"]["benchmark"] + "/fastp_pe.txt"
    resources:
        mem_mb=config["normal_mem"],
        # runtime=config["normal_time"],
    conda:
        config["path"]["envs"] + "/fastp.yaml"
    message:
        "[fastp_pe] Executing FASTP quality control/pre-processing (trimming) on raw reads..."
    threads: config["threads"]
    shell:
        """
        mkdir -p {output.dir}
        fastp -i {input.R1} -I {input.R2} -o {output.R1} -O {output.R2}\
        -h {output.html} -j {output.json}\
        &> {log}
        """


rule fastqc_qc:
    """
    Performes quality control of processed QC reads
    """
    input:
        rules.fastp_pe.output.R1,
        rules.fastp_pe.output.R2,
    output:
        dir=directory(config["path"]["output"] + "/fastqc_qc/"),
        report=list(
            set(
                expand(
                    config["path"]["output"]
                    + "/fastqc_qc/{sample}_{frac}_fastqc.html",
                    sample=SAMPLE,
                    frac=FRAC,
                )
            )
        ),
    threads: config["threads"]
    conda:
        config["path"]["envs"] + "/fastqc.yaml"
    message:
        "[fastqc_qc] Executing FASTQC quality control on trimmed reads..."
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    log:
        config["path"]["log"] + "/fastqc_qc.log",
    benchmark:
        config["path"]["benchmark"] + "/fastqc_qc.txt"
    shell:
        """
        mkdir -p {output.dir}
        fastqc {input} -o {output.dir} &> {log}
        """


rule QC:
    input:
        rules.fastqc_raw.output,
        rules.fastp_pe.output,
        rules.fastqc_qc.output,
    output:
        config["path"]["temp"] + "/finished_qc",
    threads: 1
    message:
        "[QC] Finished QC."
    shell:
        """
        touch {output}
        """


# ASSEMBLY #


rule metaSpades:
    """
    Assembles all sequences with metaSpades
    """
    input:
        R1=rules.fastp_pe.output.R1,
        R2=rules.fastp_pe.output.R2,
    output:
        dir=directory(
            expand(
                config["path"]["output"] + "/metaSpades/{sample}/",
                sample=SAMPLE,
            )
        ),
        contigs=expand(
            config["path"]["output"] + "/metaSpades/{sample}/contigs.fasta",
            sample=SAMPLE,
        ),
        scaffolds=expand(
            config["path"]["output"] + "/metaSpades/{sample}/scaffolds.fasta",
            sample=SAMPLE,
        ),
    params:
        temp_dir=config["path"]["temp"] + "/metaSpades/",
    message:
        "[metaSpades] Performing assembly of paired end reads..."
    conda:
        config["path"]["envs"] + "/metaSpades.yaml"
    log:
        config["path"]["log"] + "/metaSpades.log",
    benchmark:
        config["path"]["benchmark"] + "/metaSpades.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["big_mem"],
        # runtime=config["big_time"],
    shell:
        """
        mkdir -p {output.dir}
        metaspades.py -1 {input.R1} -2 {input.R2} -o {output.dir}\
        --tmp-dir {params.temp_dir} -t {threads} &> {log}
        """


rule metaQUAST:
    """
    Performes quality control on all assembled contigs
    with the reference database RefSeq Viral
    """
    params:
        reference=config["path"]["database"]["RefSeq"] + "/viral.1.1.genomic.fna",
    input:
        rules.metaSpades.output.contigs,
    output:
        dir=directory(
            expand(config["path"]["output"] + "/metaQUAST/{sample}/", sample=SAMPLE)
        ),
        report=expand(
            config["path"]["output"] + "/metaQUAST/{sample}/report.html", sample=SAMPLE
        ),
        transposed_report=expand(
            config["path"]["output"]
            + "/metaQUAST/{sample}/combined_reference/transposed_report.tsv",
            sample=SAMPLE,
        ),
    message:
        "[metaQUAST] Running metaQUAST quality control on assembled contigs..."
    conda:
        config["path"]["envs"] + "/metaQUAST.yaml"
    log:
        config["path"]["log"] + "/metaQUAST.log",
    benchmark:
        config["path"]["benchmark"] + "/metaQUAST.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["metaquast_mem"],
        # runtime=config["metaquast_time"],
    shell:
        """
        mkdir -p {output.dir}
        metaquast.py {input} -o {output.dir}\
        -r {params.reference} --threads {threads} --max-ref-number 0 &> {log}
        """


rule ASSEMBLY:
    input:
        rules.metaSpades.output,
        rules.metaQUAST.output,
    output:
        config["path"]["temp"] + "/finished_ASSEMBLY",
    threads: 1
    message:
        "[ASSEMBLY] Assembly of all samples finished"
    shell:
        """
        touch {output}
        """


# VIRAL IDENTIFICATION #


rule virsorter2_pass1:
    """
    Performes the first pass of viral identification with virsorter2
    """
    params:
        cutoff_length=config["virsorter2"]["pass1"]["min_lenght"],
        cutoff_score=config["virsorter2"]["pass1"]["min_score"],
        groups=config["virsorter2"]["pass1"]["viral_groups"],
    input:
        rules.metaSpades.output.contigs,
    output:
        dir=directory(
            expand(
                config["path"]["output"] + "/virsorter2_pass1/{sample}/",
                sample=SAMPLE,
            )
        ),
        finished=expand(
            config["path"]["output"] + "/virsorter2_pass1/{sample}/finished",
            sample=SAMPLE,
        ),
    message:
        "[virsorter2_pass1] Executing viral identification..."
    conda:
        config["path"]["envs"] + "/virsorter2.yaml"
    log:
        config["path"]["log"] + "/virsorter2_pass1.log",
    benchmark:
        config["path"]["benchmark"] + "/virsorter2_pass1.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["big_mem"],
        # runtime=config["normal_time"],
    shell:
        """
        mkdir -p {output.dir}
        virsorter run -w {output.dir} \
            -j {threads} --include-groups "{params.groups}"\
            --min-length {params.cutoff_length} \
            --min-score {params.cutoff_score} \
            --keep-original-seq all\
            -i {input} &> {log}
        touch {output.finished}
        """


rule vibrant_pass1:
    """
    Performes the first pass of viral identification with VIBRANT
    """
    input:
        rules.metaSpades.output.contigs,
    output:
        dir=directory(
            expand(
                config["path"]["output"] + "/vibrant_pass1/{sample}/",
                sample=SAMPLE,
            )
        ),
        phages_combined=directory(
            expand(
                config["path"]["output"]
                + "/vibrant_pass1/{sample}/VIBRANT_contigs/VIBRANT_phages_contigs/",
                sample=SAMPLE,
            )
        ),
        finished=expand(
            config["path"]["output"] + "/vibrant_pass1/{sample}/finished",
            sample=SAMPLE,
        ),
    params:
        db_dir=config["path"]["database"]["vibrant"] + "/databases",
        files_dir=config["path"]["database"]["vibrant"] + "/files",
        virome=vibrant_virome(config["vibrant"]["is_virome"]),
    conda:
        config["path"]["envs"] + "/vibrant.yaml"
    message:
        "[vibrant_pass1] Executing viral identification..."
    log:
        config["path"]["log"] + "/vibrant_pass1.log",
    benchmark:
        config["path"]["benchmark"] + "/vibrant_pass1.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["big_mem"],
        # runtime=config["normal_time"],
    shell:
        """
        mkdir -p {output.dir}
        VIBRANT_run.py -i {input}\
            -t {threads}\
            -folder {output.dir}\
            -d {params.db_dir}\
            -m {params.files_dir}\
            {params.virome}\
            &> {log}
        touch {output.finished}
        """


rule checkv_virsorter2:
    """
    Performes Quality control on identified viral sequences
    """
    params:
        db_dir=config["path"]["database"]["checkv"] + "/checkv-db-v1.5",
        fa_paths=[
            f"{d}/final-viral-combined.fa" for d in rules.virsorter2_pass1.output.dir
        ],
    input:
        rules.virsorter2_pass1.output.dir,
        rules.virsorter2_pass1.output.finished,
    output:
        dir=directory(
            expand(
                config["path"]["output"] + "/checkv/virsorter2_pass1/{sample}/",
                sample=SAMPLE,
            )
        ),
        summary=expand(
            config["path"]["output"]
            + "/checkv/virsorter2_pass1/{sample}/quality_summary.tsv",
            sample=SAMPLE,
        ),
        combined=expand(
            config["path"]["output"]
            + "/checkv/virsorter2_pass1/{sample}/combined.fna",
            sample=SAMPLE,
        ),
    conda:
        config["path"]["envs"] + "/checkv.yaml"
    message:
        "[checkv_virsorter2_pass1] Executing quality control on identified sequences..."
    log:
        config["path"]["log"] + "/checkv_virsorter2_pass1.log",
    benchmark:
        config["path"]["benchmark"] + "/checkv_virsorter2_pass1.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["normal_mem"],
        # runtime=config["small_time"],
    shell:
        """
        mkdir -p {output.dir}
        diamond makedb --in {params.db_dir}/genome_db/checkv_reps.faa \
            --db {params.db_dir}/genome_db/checkv_reps &> {log}
        checkv end_to_end {params.fa_paths} {output.dir} -t {threads} -d {params.db_dir} &>> {log}
        cat {output.dir}/proviruses.fna {output.dir}/viruses.fna > {output.combined}
        """


rule checkv_vibrant:
    """
    Performes Quality control on identified viral sequences
    """
    input:
        rules.vibrant_pass1.output.phages_combined,
        rules.vibrant_pass1.output.finished,
    params:
        db_dir=config["path"]["database"]["checkv"] + "/checkv-db-v1.5",
        fna_paths=[
            f"{d}/contigs.phages_combined.fna"
            for d in rules.vibrant_pass1.output.phages_combined
        ],
    output:
        dir=directory(
            expand(
                config["path"]["output"] + "/checkv/vibrant_pass1/{sample}/",
                sample=SAMPLE,
            )
        ),
        summary=expand(
            config["path"]["output"]
            + "/checkv/vibrant_pass1/{sample}/quality_summary.tsv",
            sample=SAMPLE,
        ),
        combined=expand(
            config["path"]["output"] + "/checkv/vibrant_pass1/{sample}/combined.fna",
            sample=SAMPLE,
        ),
    conda:
        config["path"]["envs"] + "/checkv.yaml"
    message:
        "[checkv_vibrant_pass1] Executing quality control on identified sequences..."
    log:
        config["path"]["log"] + "/checkv_vibrant_pass1.log",
    benchmark:
        config["path"]["benchmark"] + "/checkv_vibrant_pass1.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["normal_mem"],
        # runtime=config["small_time"],
    shell:
        """
        mkdir -p {output.dir}
        diamond makedb --in {params.db_dir}/genome_db/checkv_reps.faa \
            --db {params.db_dir}/genome_db/checkv_reps &> {log}
        checkv end_to_end {params.fna_paths}\
        {output.dir} -t {threads} -d {params.db_dir} &>> {log}
        cat {output.dir}/proviruses.fna {output.dir}/viruses.fna > {output.combined}
        """


rule filter_contigs_virsorter2:
    """
    Gathers only relevant sequences with above threshold score
    """
    params:
        criteria=get_min_quality(config["quality_threshold"]),
    input:
        summary=rules.checkv_virsorter2.output.summary,
        combined=rules.checkv_virsorter2.output.combined,
    output:
        dir=directory(
            expand(
                config["path"]["output"] + "/filtered_virsorter2/{sample}/",
                sample=SAMPLE,
            )
        ),
        filtered_contigs_viruses=expand(
            config["path"]["output"]
            + "/filtered_virsorter2/{sample}/filtered_combined.fna",
            sample=SAMPLE,
        ),
        filtered_contigs_ID=expand(
            config["path"]["output"]
            + "/filtered_virsorter2/{sample}/filtered_contigs",
            sample=SAMPLE,
        ),
    conda:
        config["path"]["envs"] + "/seqtk.yaml"
    message:
        "[filter_contigs_virsorter2] Filtering contigs with respect to quality scores (quality threshold: {params.criteria})..."
    benchmark:
        config["path"]["benchmark"] + "/filter_contigs_virsorter2.txt"
    log:
        config["path"]["log"] + "/filter_contigs_virsorter2.log",
    threads: config["threads"]
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["small_time"],
    shell:
        """
        mkdir -p {output.dir}
        awk -F '\t' '{params.criteria}  {{print $1}}' {input.summary} > {output.filtered_contigs_ID}
        seqtk subseq {input.combined} {output.filtered_contigs_ID} > {output.filtered_contigs_viruses}
        """


rule filter_contigs_vibrant:
    """
    Gathers only relevant sequences with above threshold score
    """
    params:
        criteria=get_min_quality(config["quality_threshold"]),
    input:
        summary=rules.checkv_vibrant.output.summary,
        combined=rules.checkv_vibrant.output.combined,
    output:
        dir=directory(
            expand(
                config["path"]["output"] + "/filtered_vibrant/{sample}/",
                sample=SAMPLE,
            )
        ),
        filtered_contigs_viruses=expand(
            config["path"]["output"]
            + "/filtered_vibrant/{sample}/filtered_combined.fna",
            sample=SAMPLE,
        ),
        filtered_contigs_ID=expand(
            config["path"]["output"] + "/filtered_vibrant/{sample}/filtered_contigs",
            sample=SAMPLE,
        ),
    conda:
        config["path"]["envs"] + "/seqtk.yaml"
    message:
        "[filter_contigs_vibrant] Filtering contigs with respect to quality scores (quality threshold: {params.criteria})..."
    benchmark:
        config["path"]["benchmark"] + "/filter_contigs_vibrant.txt"
    log:
        config["path"]["log"] + "/filter_contigs_vibrant.log",
    threads: config["threads"]
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["small_time"],
    shell:
        """
        mkdir -p {output.dir}
        awk -F '\t' '{params.criteria}  {{print $1}}' {input.summary} > {output.filtered_contigs_ID}
        seqtk subseq {input.combined} {output.filtered_contigs_ID} > {output.filtered_contigs_viruses}
        """


rule combine_results_virsorter2:
    """
    Combine all results from virus identifiaction of all samples with virsorter2
    """
    input:
        rules.filter_contigs_virsorter2.output.filtered_contigs_viruses,
    output:
        dir=directory(config["path"]["output"] + "/combined_virsorter2/"),
        combined=config["path"]["output"]
        + "/combined_virsorter2/combined_virsorter2.tsv",
    conda:
        config["path"]["envs"] + "/cdhit.yaml"
    message:
        "[combine_results_virsorter2] Combining results from all samples..."
    log:
        config["path"]["log"] + "/combine_results_virsorter2.log",
    benchmark:
        config["path"]["benchmark"] + "/combine_results_virsorter2.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["small_time"],
    shell:
        """
        mkdir -p {output.dir}
        cat {input} > {output.combined}
        """


rule combine_results_vibrant:
    """
    Combine all results from virus identifiaction of all samples with VIBRANT
    """
    input:
        rules.filter_contigs_vibrant.output.filtered_contigs_viruses,
    output:
        dir=directory(config["path"]["output"] + "/combined_vibrant/"),
        combined=config["path"]["output"] + "/combined_vibrant/combined_vibrant.tsv",
    conda:
        config["path"]["envs"] + "/cdhit.yaml"
    message:
        "[combine_results_vibrant] Combining results from all samples..."
    log:
        config["path"]["log"] + "/combine_results_vibrant.log",
    benchmark:
        config["path"]["benchmark"] + "/combine_results_vibrant.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["small_time"],
    shell:
        """
        mkdir -p {output.dir}
        cat {input} > {output.combined}
        """


rule combine_all_results:
    """
    Combine all results from both virus identifiaction tools
    """
    input:
        vibrant=rules.combine_results_vibrant.output.combined,
        virsorter2=rules.combine_results_virsorter2.output.combined,
    output:
        dir=directory(
            config["path"]["output"] + "/combined_all/",
        ),
        combined=config["path"]["output"] + "/combined_all/combined_all.fasta",
    conda:
        config["path"]["envs"] + "/cdhit.yaml"
    message:
        "[combine_all_results] Combining results from virsorter2 and VIBRANT..."
    log:
        config["path"]["log"] + "/combine_all_results.log",
    benchmark:
        config["path"]["benchmark"] + "/combine_all_results.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    shell:
        """
        mkdir -p {output.dir}
        cat {input.vibrant}\
        > {output.combined}
        """
        # {input.virsorter2}


rule dereplication:
    """
    Performs dereplication with clustering on the viral sequences
    """
    input:
        rules.combine_all_results.output.combined,
    output:
        dir=directory(config["path"]["output"] + "/cdhit/"),
        derep=config["path"]["output"] + "/cdhit/derep95_combined.fasta",
    conda:
        config["path"]["envs"] + "/cdhit.yaml"
    message:
        "[dereplication] Dereplication of viral sequences..."
    log:
        config["path"]["log"] + "/dereplication.log",
    benchmark:
        config["path"]["benchmark"] + "/dereplication.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["normal_mem"],
        # runtime=config["small_time"],
    shell:
        """
        mkdir -p {output.dir}
        cd-hit-est\
        -T {threads}\
        -M {resources.mem_mb}\
        -i {input}\
        -o {output.derep}\
        -c 0.95\
        -aS 0.85\
        -n 9\
        -d 0\
        -p 1\
        -t 4\
        -g 1\
        &> {log}
        """


rule transform_vOTUs:
    """
    Renames viral sequences to unique vOTU_# names
    """
    input:
        rules.dereplication.output.derep,
    output:
        dir=directory(config["path"]["output"] + "/vOTU/"),
        vOTU=config["path"]["output"] + "/vOTU/vOTU_derep95_combined.fasta",
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    conda:
        config["path"]["envs"] + "/seqtk.yaml"
    message:
        "[transform_vOTUs] Renaming viral sequences to vOTU_#..."
    log:
        config["path"]["log"] + "/transform_vOTUs.log",
    benchmark:
        config["path"]["benchmark"] + "/transform_vOTUs.txt"
    shell:
        """
        mkdir -p {output.dir}
        awk '/^>/{{print ">vOTU_" ++i; next}}{{print}}' {input} > {output.vOTU}
        """


rule virsorter2_pass2:
    """
    Runs virsorter2 on the vOTUs
    """
    params:
        cutoff_length=config["virsorter2"]["pass2"]["min_lenght"],
        cutoff_score=config["virsorter2"]["pass2"]["min_score"],
        groups=config["virsorter2"]["pass2"]["viral_groups"],
    input:
        rules.transform_vOTUs.output.vOTU,
    output:
        dir=directory(config["path"]["output"] + "/virsorter2_pass2/"),
        finished=config["path"]["output"] + "/virsorter2_pass2/finished",
    message:
        "[virsorter2_pass2] Running virsorter2 on the vOTUs..."
    conda:
        config["path"]["envs"] + "/virsorter2.yaml"
    log:
        config["path"]["log"] + "/virsorter2_pass2.log",
    benchmark:
        config["path"]["benchmark"] + "/virsorter2_pass2.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["big_mem"],
        # runtime=config["normal_time"],
    shell:
        """
        mkdir -p {output.dir}
        virsorter run -w {output.dir} \
            -j {threads} --include-groups "{params.groups}"\
            --seqname-suffix-off\
            --viral-gene-enrich-off\
            --prep-for-dramv\
            --min-length {params.cutoff_length} \
            --min-score {params.cutoff_score} \
            --keep-original-seq all\
            -i {input} &> {log}
        touch {output.finished}
        """


rule vibrant_pass2:
    """
    Runs VIBRANT on the vOTUs
    """
    input:
        rules.transform_vOTUs.output.vOTU,
    output:
        dir=directory(config["path"]["output"] + "/vibrant_pass2/"),
        phages_combined=directory(
            config["path"]["output"]
            + "/vibrant_pass2/VIBRANT_vOTU_derep95_combined/VIBRANT_phages_vOTU_derep95_combined/",
        ),
        finished=config["path"]["output"] + "/vibrant_pass2/finished",
    params:
        db_dir=config["path"]["database"]["vibrant"] + "/databases",
        files_dir=config["path"]["database"]["vibrant"] + "/files",
        virome=vibrant_virome(config["vibrant"]["is_virome"]),
    conda:
        config["path"]["envs"] + "/vibrant.yaml"
    message:
        "[vibrant_pass2] Running VIBRANT on the vOTUs..."
    log:
        config["path"]["log"] + "/vibrant_pass2.log",
    benchmark:
        config["path"]["benchmark"] + "/vibrant_pass2.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["big_mem"],
        # runtime=config["normal_time"],
    shell:
        """
        mkdir -p {output.dir}
        VIBRANT_run.py -i {input}\
            -t {threads}\
            -folder {output.dir}\
            -d {params.db_dir}\
            -m {params.files_dir}\
            {params.virome}\
            &> {log}
        touch {output.finished}
        """


rule checkv_vOTU_virsorter2:
    """
    Runs Quality control on the vOTUs after virsorter2
    """
    params:
        db_dir=config["path"]["database"]["checkv"] + "/checkv-db-v1.5",
    input:
        dir=rules.virsorter2_pass2.output.dir,
        finished=rules.virsorter2_pass2.output.finished,
    output:
        dir=directory(config["path"]["output"] + "/checkv/virsorter2_pass2/"),
        summary=config["path"]["output"]
        + "/checkv/virsorter2_pass2/quality_summary.tsv",
    conda:
        config["path"]["envs"] + "/checkv.yaml"
    message:
        "[checkv_vOTU_virsorter2] Running checkv on the vOTUs after virsorter2..."
    log:
        config["path"]["log"] + "/checkv_virsorter2_pass2.log",
    benchmark:
        config["path"]["benchmark"] + "/checkv_virsorter2_pass2.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["normal_mem"],
        # runtime=config["small_time"],
    shell:
        """
        mkdir -p {output.dir}
        diamond makedb --in {params.db_dir}/genome_db/checkv_reps.faa \
        --db {params.db_dir}/genome_db/checkv_reps &>{log}
        checkv end_to_end {input.dir}/final-viral-combined.fa {output.dir} -t {threads} -d {params.db_dir} &>> {log}
        """


rule checkv_vOTU_vibrant:
    """
    Runs Quality control on the vOTUs after VIBRANT
    """
    input:
        combined=rules.vibrant_pass2.output.phages_combined,
        finished=rules.vibrant_pass2.output.finished,
    params:
        db_dir=config["path"]["database"]["checkv"] + "/checkv-db-v1.5",
    output:
        dir=directory(config["path"]["output"] + "/checkv/vibrant_pass2/"),
        summary=config["path"]["output"] + "/checkv/vibrant_pass2/quality_summary.tsv",
    conda:
        config["path"]["envs"] + "/checkv.yaml"
    message:
        "[checkv_vOTU_vibrant] Running checkv on the vOTUs after VIBRANT..."
    log:
        config["path"]["log"] + "/checkv_vibrant_pass2.log",
    benchmark:
        config["path"]["benchmark"] + "/checkv_vibrant_pass2.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["normal_mem"],
        # runtime=config["small_time"],
    shell:
        """
        mkdir -p {output.dir}
        diamond makedb --in {params.db_dir}/genome_db/checkv_reps.faa \
        --db {params.db_dir}/genome_db/checkv_reps &>{log}
        checkv end_to_end {input.combined}/vOTU_derep95_combined.phages_combined.fna\
        {output.dir} -t {threads} -d {params.db_dir} &>> {log}
        """


rule IDENTIFICATION:
    input:
        rules.virsorter2_pass1.output,
        rules.vibrant_pass1.output,
        rules.checkv_virsorter2.output,
        rules.checkv_vibrant.output,
        rules.filter_contigs_virsorter2.output,
        rules.filter_contigs_vibrant.output,
        rules.combine_results_virsorter2.output,
        rules.combine_results_vibrant.output,
        rules.combine_all_results.output,
        rules.dereplication.output,
        rules.transform_vOTUs.output,
        rules.virsorter2_pass2.output,
        rules.vibrant_pass2.output,
        rules.checkv_vOTU_virsorter2.output,
        rules.checkv_vOTU_vibrant.output,
    output:
        config["path"]["temp"] + "/finished_identification",
    threads: 1
    message:
        "[IDENTIFICATION] Finished identification of viral contigs"
    shell:
        """
        touch {output}
        """


# MAPPING


rule build_index:
    """
    Builds an index to prepare for mapping
    """
    input:
        rules.transform_vOTUs.output.vOTU,
    output:
        index_dir=directory(config["path"]["output"] + "/mapping/index"),
    conda:
        config["path"]["envs"] + "/bowtie2.yaml"
    message:
        "[build_index] Building index for mapping..."
    benchmark:
        config["path"]["benchmark"] + "/build_index.txt"
    log:
        config["path"]["log"] + "/bowtie2_build_index.log",
    threads: config["threads"]
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    shell:
        """
        mkdir -p {output.index_dir}
        bowtie2-build {input} {output.index_dir}/mapping_index &> {log}
        """


rule read_mapping:
    """
    Performes read mapping between original sample and vOTUs
    """
    input:
        R1=rules.fastp_pe.output.R1,
        R2=rules.fastp_pe.output.R2,
        index_dir=rules.build_index.output.index_dir,
    output:
        expand(
            config["path"]["output"] + "/mapping/SAM/{sample}.map.sam", sample=SAMPLE
        ),
    conda:
        config["path"]["envs"] + "/bowtie2.yaml"
    log:
        config["path"]["log"] + "/bowtie2_mapping.log",
    benchmark:
        config["path"]["benchmark"] + "/bowtie2_mapping.txt"
    threads: config["threads"]
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    shell:
        """
        bowtie2 -p {threads} -x {input.index_dir}/mapping_index -1 {input.R1} -2 {input.R2} -S {output} &> {log}
        """


rule contig_stats:
    """
    Creates simple coverage statisitcs for each read mapping
    """
    input:
        genomes=config["path"]["output"] + "/vOTU/vOTU_derep95_combined.fasta",
        sam=rules.read_mapping.output,
    output:
        basecov=expand(
            config["path"]["output"]
            + "/contig_stats/{sample}/postfilter_base_coverage.txt.gz",
            sample=SAMPLE,
        ),
        covhist=expand(
            config["path"]["output"]
            + "/contig_stats/{sample}/postfilter_coverage_histogram.txt",
            sample=SAMPLE,
        ),
        covstats=expand(
            config["path"]["output"]
            + "/contig_stats/{sample}/postfilter_coverage_stats.txt",
            sample=SAMPLE,
        ),
        bincov=expand(
            config["path"]["output"]
            + "/contig_stats/{sample}/postfilter_coverage_binned.txt",
            sample=SAMPLE,
        ),
    conda:
        config["path"]["envs"] + "/bowtie2.yaml"
    log:
        config["path"]["log"] + "/contig_stats.log",
    benchmark:
        config["path"]["benchmark"] + "/contig_stats.txt"
    message:
        "[contig_stats] Creating coverage statistics for each sample..."
    threads: config["threads"]
    resources:
        mem_mb=config["small_mem"],
        # runtime=config["tiny_time"],
    shell:
        """
        pileup.sh ref={input.genomes} in={input.sam} \
            threads={threads} \
            -Xmx{resources.mem_mb}m \
            covstats={output.covstats} \
            hist={output.covhist} \
            basecov={output.basecov}\
            concise=t \
            secondary=t \
            bincov={output.bincov} &> {log}
        """


rule get_trimmed_coverage:
    """
    Gets the trimmed mean of the coverage
    """
    input:
        basecov=rules.contig_stats.output.basecov,
        covstats=rules.contig_stats.output.covstats
    output:
        trimmed_mean=expand(
            config["path"]["output"]
            + "/contig_stats/{sample}/trimmed_mean_coverage.tsv",
            sample=SAMPLE,
        ),
    # conda:
    #     config["path"]["envs"] + "/scripts.yaml"
    params:
        trim_perc=config["trim_percentage"],
    log:
        config["path"]["log"] + "/trimmed_mean.log",
    benchmark:
        config["path"]["benchmark"] + "/trimmed_mean.txt"
    message:
        "[get_trimmed_coverage] Getting trimmed mean of coverage..."
    script:
        config["path"]["scripts"] + "/trimmed_mean.py"


# rule combine_coverage:
#     """
#     Combines all the coverages into one file,
#     prepeares for making the relative abundance
#     """
#     input:
#         covstats=expand(
#             config["path"]["output"]
#             + "/contig_stats/{sample}/postfilter_coverage_stats.txt",
#             sample=SAMPLE,
#         ),
#     output:
#         abundance_table=config["path"]["output"]
#         + "/contig_stats/raw_coverage_table.tsv",
#     params:
#         min_coverage=config["min_coverage"]
#     conda:
#         config["path"]["envs"] + "/scripts.yaml"
#     message:
#         "[combine_coverage] Combining coverage statistics..."
#     script:
#         config["path"]["scripts"] + "combine_coverage.R"


rule MAPPING:
    input:
        rules.build_index.output,
        rules.read_mapping.output,
        rules.contig_stats.output,
        rules.get_trimmed_coverage.output,
        # rules.combine_coverage.output,
    output:
        config["path"]["temp"] + "/finished_mapping",
    threads: 1
    message:
        "[MAPPING] Mapping finished..."
    shell:
        """
        touch {output}
        """


# rule prodigal:
#     """
#     Performes gene prediction on vOTUs
#     """
#     params:
#         out_dir=config["path"]["output"] + "/prodigal/",
#     input:
#         genomes=config["path"]["output"] + "/cdhit/vOTU_derep95_combined.fasta",
#     output:
#         proteins=config["path"]["output"] + "/prodigal/proteins.faa",
#         orf=config["path"]["output"] + "/prodigal/orfs.genes",
#     conda:
#         config["path"]["envs"] + "/prodigal.yaml"
#     log:
#         "logs/prodigal.log",
#     benchmark:
#         "benchmarks/prodigal/prodigal.tsv"
#     threads: 2
#     resources:
#         mem_mb=config["small_mem"],
#         runtime=config["tiny_time"],
#     shell:
#         """
#     prodigal -i {input.genomes} -o {output.proteins} -a {output.orf} -p meta\
#     &> {log}
#     """


# rule gene2genome:
#     """
#     Performes gene2genome setup for VCONTACT2
#     """
#     input:
#         proteins=config["path"]["output"] + "/prodigal/orfs.genes",
#     output:
#         g2g=config["path"]["output"] + "/vcontact2/genes_2_genomes/g2g.csv",
#     conda:
#         config["path"]["envs"] + "/vcontact2.yaml"
#     log:
#         "logs/Vcontact2_gene2genome.log",
#     resources:
#         mem_mb=config["small_mem"],
#         runtime=config["tiny_time"],
#     shell:
#         """
#     vcontact2_gene2genome -p {input.proteins} -o {output.g2g} -s 'Prodigal-FAA'\
#     &> {log}
#     """


# rule inphared_setup:
#     """
#     Adds relevant entires from INPHARED into setup files before VCONTACT2
#     """
#     params:
#         inphared_g2g=config["database_dir"]["INPHARED"]
#         + "/1Dec2022_vConTACT2_gene_to_genome.csv",
#         inphared_proteins=config["database_dir"]["INPHARED"]
#         + "/1Dec2022_vConTACT2_proteins.faa",
#         simplify_faa="workflow/scripts/simplify_faa-ffn_derep.py",
#     input:
#         g2g=config["path"]["output"] + "/vcontact2/genes_2_genomes/g2g.csv",
#         proteins=config["path"]["output"] + "/prodigal/proteins.faa",
#         orf=config["path"]["output"] + "/prodigal/orfs.genes",
#     output:
#         combinedg2g=config["path"]["output"] + "/vcontact2/genes_2_genomes/viral_genomes_combined.csv",
#         combined_proteins=config["path"]["output"] + "/vcontact2/genes_2_genomes/combined_proteins.faa",
#         simplified_orfs=config["path"]["output"] + "/prodigal/orfs.genes.simple.faa",
#     benchmark:
#         "benchmarks/inphared/setup.tsv"
#     conda:
#         config["path"]["envs"] + "/vibrant.yaml"
#     resources:
#         mem_mb=config["small_mem"],
#         runtime=config["tiny_time"],
#     shell:
#         """
#     cat {input.g2g} {params.inphared_g2g} > {output.combinedg2g}
#     sed -i 's/,None_provided/,none/g' {output.combinedg2g}
#     python3 {params.simplify_faa} {input.orf}
#     cat {input.orf}.simple.faa {params.inphared_proteins} > {output.combined_proteins}
#     """


# rule vcontact2:
#     """
#     Performs Taxonomic annotation with VCONTACT2
#     """
#     input:
#         proteins=config["path"]["output"] + "/vcontact2/genes_2_genomes/combined_proteins.faa",
#         g2g=config["path"]["output"] + "/vcontact2/genes_2_genomes/viral_genomes_combined.csv",
#     output:
#         cluster_overview=config["path"]["output"] + "/vcontact2/viral_cluster_overview.csv",
#         genome_by_genome=config["path"]["output"] + "/vcontact2/genome_by_genome_overview.csv",
#         network=config["path"]["output"] + "/vcontact2/c1.ntw",
#     params:
#         outdir=config["path"]["output"] + "/vcontact2/",
#     benchmark:
#         "benchmarks/vcontact2/vcontact2.tsv"
#     conda:
#         config["path"]["envs"] + "/vcontact2.yaml"
#     log:
#         "logs/Vcontact2.log",
#     resources:
#         mem_mb=config["vcontact2_mem"],
#         runtime=config["vcontact2_time"],
#         partition=config["job_type"]["normal"],
#     threads: 24
#     shell:
#         """
#             rm -rdf {params.outdir}combined*
#             vcontact2 -t {threads} \
#                 --raw-proteins {input.proteins} \
#                 --rel-mode 'Diamond' \
#                 --proteins-fp {input.g2g} \
#                 --db 'None' \
#                 --pcs-mode MCL \
#                 --vcs-mode ClusterONE \
#                 --output-dir {params.outdir} \
#                 &> {log}
#     """


rule TAXONOMY:
    input:
        # rules.prodigal.output,
        # rules.gene2genome.output,
        # rules.inphared_setup.output,
        # rules.vconcat2.output,
    output:
        config["path"]["output"] + "/taxonomy_finished",
    threads: 1
    shell:
        """
        touch {output}
        """


# rule dramv_annotate:
#     """
#     Performs Functional annotation with DRAMv
#     """
#     input:
#         affi_contigs=config["path"]["output"] + "/virsorter2/pass2/for-dramv/viral-affi-contigs-for-dramv.tab",
#         viruses=config["path"]["output"] + "/virsorter2/pass2/for-dramv/final-viral-combined-for-dramv.fa",
#     output:
#         results=config["path"]["output"] + "/DRAMv/annotations.tsv",
#     params:
#         dram_config=config["database_dir"]["DRAM"] + "/DRAM.config",
#         output_dir=config["path"]["output"] + "/DRAMv",
#     conda:
#         config["path"]["envs"] + "/DRAMv.yaml"
#     log:
#         "logs/DRAMV/DRAM_annotate.log",
#     benchmark:
#         "benchmarks/DRAMv_annotate.tsv"
#     resources:
#         mem_mb=config["big_mem"],
#         runtime=config["big_time"],
#     threads: 10
#     shell:
#         """
#         DRAM-setup.py import_config --config_loc {params.dram_config}
#         rm -rdf {params.output_dir}
#         DRAM-v.py annotate -i {input.viruses}\
#         -v {input.affi_contigs}\
#         -o dramv-annotate \
#         --output_dir {params.output_dir}\
#         --threads {threads}\
#         --min_contig_size 1000\
#         &> {log}
#     """


# rule dramv_distill:
#     """
#     Performs the distillation of functional annotation
#     """
#     input:
#         dramv_annnotations=config["path"]["output"] + "/DRAMv/annotations.tsv",
#     output:
#         distilled=config["path"]["output"] + "/DRAMv/distilled/amg_summary.tsv",
#     params:
#         output_dir=config["path"]["output"] + "/DRAMv/distilled/",
#     log:
#         "logs/DRAMV/DRAM_distill.log",
#     benchmark:
#         "benchmarks/DRAMv_distill.tsv"
#     conda:
#         config["path"]["envs"] + "/DRAMv.yaml"
#     resources:
#         mem_mb=config["normal_mem"],
#         runtime=config["normal_time"],
#     shell:
#         """
#         rm -rd {params.output_dir}
#         DRAM-v.py distill -i {input.dramv_annnotations}\
#         -o dramv-distill\
#         --output_dir {params.output_dir}\
#         &> {log}
#     """


# rule graphanalyzer:
#     """
#     Performs the post-processing of VCONTACT2 results
#     automatically
#     """
#     params:
#         graph="workflow/scripts/graphanalyzer.py",
#     input:
#         cluster=config["path"]["output"] + "/vcontact2/c1.ntw",
#         csv=config["path"]["output"] + "/vcontact2/genome_by_genome_overview.csv",
#         meta=config["database_dir"]["INPHARED"] + "/1Dec2022_data_excluding_refseq.tsv",
#     output:
#         config["path"]["output"] + "/graphanalyzer/csv_edit_vOTU_results.xlsx",
#     conda:
#         config["path"]["envs"] + "/graphanalyzer.yaml"
#     threads: 6
#     resources:
#         mem_mb=config["normal_mem"],
#         runtime=config["normal_time"],
#     log:
#         "logs/graphanalyzer/graphanalyzer.log",
#     shell:
#         """
#         python3 {params.graph}\
#         --graph {input.cluster}\
#         --csv {input.csv}\
#         --metas {input.meta}\
#         --output ./results/graphanalyzer/\
#         --prefix vOTU\
#         --suffix vOTU_results\
#         --threads {threads}\
#         &> {log}
#     """


# localrules:
#     get_stats,
# rule get_stats:
#     """
#     Performs the aggregation of all relevant files into summaries tables and plots
#     """
#     input:
#         config["path"]["output"] + "/graphanalyzer/csv_edit_vOTU_results.xlsx",
#         config["path"]["output"] + "/DRAMv/distilled/amg_summary.tsv",
#         config["path"]["output"] + "/checkv/vOTU/virsorter2/quality_summary.tsv",
#         config["path"]["output"] + "/checkv/vOTU/vibrant/quality_summary.tsv",
#         config["path"]["output"] + "/metaQUAST/combined_reference/transposed_report.tsv",
#     output:
#         config["path"]["output"] + "/statistics/Sample_stats_vibrant.tsv",
#         config["path"]["output"] + "/statistics/Sample_stats_virsorter2.tsv",
#         config["path"]["output"] + "/statistics/vOTU_Stats_vibrant.tsv",
#         config["path"]["output"] + "/statistics/vOTU_Stats_virsorter2.tsv",
#         config["path"]["output"] + "/statistics/vOTU_AMGs.tsv",
#     script:
#         config["path"]["scripts"] + "table_stats.py"
# rule ASSEMBLY:
#     input:
#         expand(config["path"]["output"] + "/metaSpades_ASSEMBLY/{sample}/contigs.fasta", sample=SAMPLE),
#         expand(config["path"]["output"] + "/metaSpades_ASSEMBLY/{sample}/scaffolds.fasta", sample=SAMPLE),
#         config["path"]["output"] + "/metaQUAST/report.html",
#         config["path"]["output"] + "/metaQUAST/combined_reference/transposed_report.tsv",
#     output:
#         touch("finished_ASSEMBLY"),
# rule identification:
#     input:
#         expand(config["path"]["output"] + "/virsorter2/{sample}/final-viral-combined.fa", sample=SAMPLE),
#         expand(config["path"]["output"] + "/virsorter2/{sample}/final-viral-score.tsv", sample=SAMPLE),
#         expand(
#             config["path"]["output"] + "/vibrant/{sample}/VIBRANT_contigs/VIBRANT_phages_contigs/contigs.phages_combined.fna",
#             sample=SAMPLE,
#         ),
#         expand(
#             config["path"]["output"] + "/checkv/{assembler}/{sample}/quality_summary.tsv",
#             sample=SAMPLE,
#             assembler=ASSEMBLER,
#         ),
#         expand(
#             config["path"]["output"] + "/checkv/{assembler}/{sample}/combined.fna",
#             sample=SAMPLE,
#             assembler=ASSEMBLER,
#         ),
#         expand(
#             config["path"]["output"] + "/checkv/virsorter2/{sample}/filtered/filtered_combined.fna",
#             sample=SAMPLE,
#         ),
#         expand(
#             config["path"]["output"] + "/checkv/virsorter2/{sample}/filtered/filtered_contigs",
#             sample=SAMPLE,
#         ),
#         expand(
#             config["path"]["output"] + "/checkv/vibrant/{sample}/filtered/filtered_combined.fna",
#             sample=SAMPLE,
#         ),
#         expand(
#             config["path"]["output"] + "/checkv/vibrant/{sample}/filtered/filtered_contigs", sample=SAMPLE
#         ),
#         config["path"]["output"] + "/checkv/vOTU/virsorter2/quality_summary.tsv",
#         config["path"]["output"] + "/checkv/vOTU/vibrant/quality_summary.tsv",
#         config["path"]["output"] + "/virsorter2/pass2/for-dramv/viral-affi-contigs-for-dramv.tab",
#         config["path"]["output"] + "/virsorter2/pass2/for-dramv/final-viral-combined-for-dramv.fa",
#         config["path"]["output"] + "/virsorter2/pass2/final-viral-combined.fa",
#         config["path"]["output"] + "/vibrant/vOTU/VIBRANT_vOTU_derep95_combined/VIBRANT_phages_vOTU_derep95_combined/vOTU_derep95_combined.phages_combined.fna",
#         config["path"]["output"] + "/cdhit/prep/combined_virsorter2.fasta",
#         config["path"]["output"] + "/cdhit/prep/combined_vibrant.fasta",
#         config["path"]["output"] + "/cdhit/prep/combined_all.fasta",
#         config["path"]["output"] + "/mapping/index.done",
#         config["path"]["output"] + "/cdhit/derep95_combined.fasta",
#         config["path"]["output"] + "/cdhit/vOTU_derep95_combined.fasta",
#         expand(config["path"]["output"] + "/mapping/{sample}/{sample}.map.sam", sample=SAMPLE),
#         expand(
#             config["path"]["output"] + "/contig_stats/{sample}/postfilter_base_coverage.txt.gz",
#             sample=SAMPLE,
#         ),
#         expand(
#             config["path"]["output"] + "/contig_stats/{sample}/postfilter_coverage_histogram.txt",
#             sample=SAMPLE,
#         ),
#         expand(
#             config["path"]["output"] + "/contig_stats/{sample}/postfilter_coverage_stats.txt",
#             sample=SAMPLE,
#         ),
#         expand(
#             config["path"]["output"] + "/contig_stats/{sample}/postfilter_coverage_binned.txt",
#             sample=SAMPLE,
#         ),
#         expand(config["path"]["output"] + "/contig_stats/{sample}/trimmed_mean_coverage.tsv", sample=SAMPLE),
#         config["path"]["output"] + "/contig_stats/raw_coverage_table.tsv",
#     output:
#         touch("finished_virus_identification"),
# rule taxonomy:
#     input:
#         config["path"]["output"] + "/prodigal/proteins.faa",
#         config["path"]["output"] + "/prodigal/orfs.genes",
#         config["path"]["output"] + "/prodigal/orfs.genes.simple.faa",
#         config["path"]["output"] + "/vcontact2/genes_2_genomes/combined_proteins.faa",
#         config["path"]["output"] + "/vcontact2/genes_2_genomes/g2g.csv",
#         config["path"]["output"] + "/vcontact2/genes_2_genomes/viral_genomes_combined.csv",
#         config["path"]["output"] + "/vcontact2/viral_cluster_overview.csv",
#         config["path"]["output"] + "/DRAMv/annotations.tsv",
#         config["path"]["output"] + "/DRAMv/distilled/amg_summary.tsv",
#         config["path"]["output"] + "/graphanalyzer/csv_edit_vOTU_results.xlsx",
#         config["path"]["output"] + "/statistics/Sample_stats_vibrant.tsv",
#         config["path"]["output"] + "/statistics/Sample_stats_virsorter2.tsv",
#         config["path"]["output"] + "/statistics/vOTU_Stats_vibrant.tsv",
#         config["path"]["output"] + "/statistics/vOTU_Stats_virsorter2.tsv",
#         config["path"]["output"] + "/statistics/vOTU_AMGs.tsv",
#     output:
#         touch("finished_taxonomy"),
# onsuccess:
#     print("Workflow finished")
# onerror:
#     print("Note the path to the log file for debugging.")


rule ALL:
    input:
        rules.QC.output,
        rules.ASSEMBLY.output,
        rules.IDENTIFICATION.output,
        rules.MAPPING.output,
    shell:
        """
        echo "All Done!"
        rm {input}
        """
